/*
 * Read json files generated by tracker-server, do preprocessing stuff,
 * recreate or symlink static files if they has changed.
 */

var $ = require('sharedjs'),
    n = require('natives'),
    deps = require('./deps'),
    utils = require('./utils');

/**
 * Default options object
 * @type {Object}
 * @export
 */
exports.options = {
    build: {
        root: null // root of src files
    },
    find: {
        detect: null, // detect deps using static require() parser
        pattern: /\.[\w]+$/, // is used if detect is not defined
        filter: null, // is used if detect is not defined
        rec: true, // recursive search
        paths: null // like require.paths to resolve deps
    },
    // processors options
    process: {
        transport: true,
        uglifyjs: true,
        // Attention, order is important!
        vendorcss: true,
        cssmin: true,
        dataimg: true
    },
    combine: null // {css: '/path/to/file'}
};

/**
 * Create new build.
 * @param {string} root path to sources root.
 * @constructor
 */
function Build(root) {
    if (!root) {
        throw new Error('root is not defined');
    }

    this.options = $.extend(true, {}, exports.options);

     // remove last slash if contained
    this.options.build.root = this.root = root.replace(/\/$/, '');
    this.paths = [root];
    this.data = {};
}

var proto = Build.prototype;

/**
 * Find files.
 * @param {Object} opts exports.options.find.
 * @this Build
 * @return {Build} this.
 */
proto.find = function(opts) {
    var o = this.options.find = $.extend({}, exports.options.find, opts),
        paths;

    if (o.paths) {
        this.paths = this.paths.concat(o.paths);
    }

    if (o.detect) {
        paths = deps.find(o.detect, o.paths);
    } else {
        paths = utils.findSync(this.root, o.pattern, o.rec);
    }

    paths.forEach(function(path) {
        if ((!o.filter || !o.filter.test(path)) &&
            (!o.pattern || o.pattern.test(path))) {
                this.data[path] = n.fs.readFileSync(path);
            }
    }, this);

    return this;
};

/**
 * Add one file from given path, it will land in the root dir.
 * @param {string} path absolute path to file.
 * @this Build
 * @return {Build} this.
 */
proto.add = function(path) {
    this.data[n.path.basename(path)] = n.fs.readFileSync(path);
    return this;
};

/**
 * Run processors on files previously readed.
 * @param {Object} opts exports.options.process.
 * @this Build
 * @return {Build} this.
 */
proto.process = function(opts) {
    var o = $.extend(this.options.process || {}, opts),
        name, proc, filter,
        i, path;

    for (name in o) {
        if (o[name]) {
            proc = require('./processors/' + name);
            // merge options with processor options
            o[name] = $.extend({}, proc.options, o[name]);
            filter = o[name].filter;
            for (path in this.data) {
                // only process files if they mach processor pattern
                if (o[name].pattern.test(path) &&
                    // check if the path should not be filtered
                    (!filter || !filter.test(path))) {
                    this.data[path] = proc.run.call(
                        this,
                        path,
                        this.data[path].toString('utf8'),
                        o[name]
                    );
                }
            }
        }
    }

    return this;
};

/**
 * Combine files.
 * @param {Object} opts exports.options.combine.
 * @this Build
 * @return {Build} this.
 */
proto.combine = function(opts) {
    var o = $.extend(this.options.combine || {}, opts),
        ext, combinePath, path, regex;

    for (ext in o) {
        combinePath = o[ext];
        regex = new RegExp('\\.' + ext + '$');
        for (path in this.data) {
            if (regex.test(path)) {
                if (typeof this.data[combinePath] !== 'string') {
                    this.data[combinePath] = '';
                }
                this.data[combinePath] += this.data[path] + '\n';
                // delete original file reference
                delete this.data[path];
            }
        }
    }

    return this;
};

/**
 * Write files to disk.
 * @param {string} targetRoot abs. path to target dir.
 * @this Build
 * @return {Build} this.
 */
proto.write = function(targetRoot) {
    var root = this.root,
        path, targetPath, data;

    if (!targetRoot) {
        throw new Error('target dir have to be specified');
    }

    // clear target Folder
    utils.rmSync(targetRoot);

    for (path in this.data) {
        // make relative path
        if (path.substr(0, 1) === '/') {
            targetPath = path.replace(root, '');
        } else {
            targetPath = path;
        }

        // make abs path to target file
        targetPath = n.path.join(targetRoot, targetPath);

        utils.mkdirSync(n.path.dirname(targetPath));

        n.fs.writeFileSync(targetPath, this.data[path]);
    }

    return this;
};

/**
 * Show success message
 * @this Build
 * @return {Build} this.
 */
proto.end = function() {
    n.util.log('Build was successfull.');
    return this;
};

/**
 * Create a new build.
 * @param {string} root path to src root.
 * @return {Build} instance of Build.
 * @export
 */
exports.build = function(root) {
    return new Build(root);
};
