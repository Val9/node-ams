/*
 * Read json files generated by tracker-server, do preprocessing stuff,
 * recreate or symlink static files if they has changed.
 */

var $ = require('../deps/sharedjs'),
    n = require('../deps/natives'),
    deps = require('./deps'),
    utils = require('./utils');

/**
 * Default options object
 * @type {Object}
 * @export
 */
exports.options = {
    find: {
        root: null, // root of src files
        detect: null, // detect deps using static require() parser
        pattern: null, // is used if detect is not defined
        filter: null, // is used if detect is not defined
        rec: true, // recursive search
        paths: null // like require.paths to resolve deps
    },
    // processors options
    process: {
        transport: true,
        uglifyjs: true,
        // Attention, order is important!
        vendorcss: true,
        cssmin: true,
        dataimg: true
    },    
    combine: null // {css: '/path/to/file'}
};


function Find(opts) {
    this.data = {};
    this.options = $.extend(true, {}, exports.options);
    
    var o = $.extend(this.options.find, opts);
    
    if (!o.root) {
        throw new Error('root option is not defined');
    }
    
    // remove last slash if contained
    o.root = o.root.replace(/\/$/, '');
    
    if (o.detect) {
        this.paths = deps.find(o.detect, o.paths);
    } else {
        this.paths = utils.findSync(o.root, o.pattern, o.rec);
    }
}

var proto = Find.prototype;

proto.getData = function(path) {
    return this.data[path] = this.data[path] || n.fs.readFileSync(path, 'utf8');
};

proto.process = function(opts) {
    var o = $.extend(this.options.process, opts),
        name, proc, filter,
        i, path;
    
    for (name in o) {
        proc = require('./processors/' + name);
        // merge options with processor options
        o[name] = $.extend({}, proc.options, o[name]);
        filter = o[name].filter;
        for (i = 0; i < this.paths.length; ++i) {
            path = this.paths[i];
            // only process files if they mach processor pattern
            if (o[name].pattern.test(path) &&
                // check if the path should not be filtered
                (!filter || !filter.test(path))) {
                this.data[path] = proc.run.call(this, path, this.getData(path), o[name]);
            }        
        }    
    }
    
    return this;    
};

proto.combine = function(opts) {
    var o = $.extend(this.options.combine, opts),
        ext, path, regex;
    
    for (ext in o) {
        regex = new RegExp('\.' + ext + '$');
        for (path in this.data) {
            if (regex.test(path)) {
                if (typeof this.data[o.ext] !== 'string') {
                    this.data[o.ext] = '';    
                }
                this.data[o.ext] += this.data[path];
                // delete original file reference
                delete this.data[path]; 
            }
        }        
    }    

    return this;    
};

proto.write = function(target) {
    var root = this.options.find.root,
        path, targetPath, data;

    if (!target) {
	    throw new Error('target dir have to be specified');        
    }

    for (path in this.data) {
        // make relative path
        targetPath = path.substr(root.length);
        // make abs path to target file
        targetPath = n.path.join(target, targetPath);

        // check if the target dir exist, if not make it
        try {
            n.fs.statSync(n.path.dirname(targetPath));
        } catch(e) {
            utils.mkdirSync(n.path.dirname(targetPath));
        }

        n.fs.writeFileSync(targetPath, this.data[path]);
    }
    
    return this;
};

exports.find = function(src, pattern, rec) {
    return new Find(src, pattern, rec);    
};
