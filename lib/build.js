/*
 * Read json files generated by tracker-server, do preprocessing stuff,
 * recreate or symlink static files if they has changed.
 */

var $ = require('../deps/sharedjs'),
    n = require('../deps/natives'),
    deps = require('./deps'),
    utils = require('./utils');

/**
 * Default options object
 * @enum {*}
 * @export
 */
exports.options = {
    // processors options
    processors: {
        transport: {
            filter: /require\.js$/
        },
        uglifyjs: true,
        cssmin: true
    },
    copy: {
        src: null, // absolute path to the sources dir
        target: null, // absolute path to the public dir
        pattern: null // regex for enabled files
    },
    combine: {
        // relative path to the bootstrap file for deps detection
        detect: 'main.js',
        main: null, // abs path to the target file
        pattern: /\.js|\.css$/, // is used if deps is not defined
        filter: null // is used if deps is not defined
    }
};


// require processors
var processors = {};
n.fs.readdirSync(__dirname + '/processors').forEach(function(name) {
    name = name.replace(/\.js$/, '');
    processors[name] = require('./processors/' + name);
});

function process(paths, o) {
    var files = {},
        name, proc, filter,
        i, path;

    for (name in o.processors) {
        proc = processors[name];
        filter = o.processors[name].filter;
        for (i = 0; i < paths.length; ++i) {
            path = paths[i];
            // only read files if they mach any processor pattern
            if (proc.pattern.test(path) && (!filter || !filter.test(path))) {
                // check if the path should not be filtered
                files[path] = files[path] || n.fs.readFileSync(path, 'utf-8');
                files[path] = proc.run(path, files[path], o);
                n.fs.writeFileSync(path, files[path]);
            }
        }
    }

    return files;
}

/**
 * Create a build.
 * @param {Object} opts options object, will extend defaults.
 * @export
 */
exports.build = function(opts) {
    var o = $.extend(true, {}, exports.options, opts),
        c = o.copy;

    // copy all files
    utils.copy(c.src, c.target, c.pattern, function(err, src, targetPaths) {
        var path, paths,
            files, data = '';

        // detect dependencies if needed for combiner
        // before running processors, because f.e. js minifier
        // will rename 'require'
        if (o.combine) {
            if (!o.combine.main) {
                throw new Error(
                    '"main" have to be defined in "combine" options'
                );
            }
            // find dependencies
            if (o.combine.detect) {
                paths = deps.find(o.combine.main);
            // filter paths if needed
            } else {
                paths = [];
                targetPaths.forEach(function(path) {
                    // path is pattern valid and is not in filter
                    if ((!o.combine.pattern || o.combine.pattern.test(path)) &&
                        (!o.combine.filter || !o.combine.filter.test(path))) {
                        paths.push(path);
                    }
                });
            }
        }

        // process files
        if (o.processors) {
            files = process(targetPaths, o);
        }

        // combine files and write them to main
        if (o.combine) {
            paths.forEach(function(path) {
                // file was already loaded by processors
                if (files && files[path]) {
                    data += files[path] + '\n';
                } else {
                    data += n.fs.readFileSync(path, 'utf-8') + '\n';
                }
            });

            n.fs.writeFileSync(o.combine.main, data);
        }
    });
};
