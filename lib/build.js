/*
 * Read json files generated by tracker-server, do preprocessing stuff,
 * recreate or symlink static files if they has changed.
 */

var $ = require('../deps/sharedjs'),
    n = require('../deps/natives'),
    deps = require('./deps'),
    utils = require('./utils');

/**
 * Default options object
 * @type {Object}
 * @export
 */
exports.options = {
    build: {
        root: null, // root of src files
    },
    find: {
        detect: null, // detect deps using static require() parser
        pattern: /\.[\w]+$/, // is used if detect is not defined
        filter: null, // is used if detect is not defined
        rec: true, // recursive search
        paths: null // like require.paths to resolve deps
    },
    // processors options
    process: {
        transport: true,
        uglifyjs: true,
        // Attention, order is important!
        vendorcss: true,
        cssmin: true,
        dataimg: true
    },    
    combine: null // {css: '/path/to/file'}
};

function Build(root) {
    if (!root) {
        throw new Error('root is not defined');
    }

    this.options = $.extend(true, {}, exports.options);

     // remove last slash if contained
    this.options.build.root = this.root = root.replace(/\/$/, '');
    this.paths = [root];
    
    this.data = {};
}

var proto = Build.prototype;

proto.find = function(opts) {
    var o = this.options.find = $.extend({}, exports.options.find, opts),
        paths;
    
    if (o.paths) {
        this.paths = this.paths.concat(o.paths);
    }

    if (o.detect) {
        paths = deps.find(o.detect, o.paths);
    } else {
        paths = utils.findSync(this.root, o.pattern, o.rec);
    }
    
    paths.forEach(function(path) {
        if ((!o.filter || !o.filter.test(path)) && 
            (!o.pattern || o.pattern.test(path))) {
                this.data[path] = n.fs.readFileSync(path);
            }
    }, this);

    return this; 
};

proto.add = function(path) {
    this.data[n.path.basename(path)] = n.fs.readFileSync(path);
    return this;
};

proto.process = function(opts) {
    var o = $.extend(this.options.process||{}, opts),
        name, proc, filter,
        i, path;
    
    for (name in o) {
        proc = require('./processors/' + name);
        // merge options with processor options
        o[name] = $.extend({}, proc.options, o[name]);
        filter = o[name].filter;
        for (path in this.data) {
            // only process files if they mach processor pattern
            if (o[name].pattern.test(path) &&
                // check if the path should not be filtered
                (!filter || !filter.test(path))) {
                this.data[path] = proc.run.call(
                    this, 
                    path, 
                    this.data[path].toString('utf8'), 
                    o[name]
                );
            }        
        }    
    }
    
    return this;    
};

proto.combine = function(opts) {
    var o = $.extend(this.options.combine||{}, opts),
        ext, combinePath, path, regex;
    
    for (ext in o) {
        combinePath = o[ext];
        regex = new RegExp('\.' + ext + '$');
        for (path in this.data) {
            if (regex.test(path)) {
                if (typeof this.data[combinePath] !== 'string') {
                    this.data[combinePath] = '';    
                }
                this.data[combinePath] += this.data[path] + '\n';
                // delete original file reference
                delete this.data[path]; 
            }
        }        
    }    
    
    return this;    
};

proto.write = function(targetRoot) {
    var root = this.root,
        path, targetPath, data;

    if (!targetRoot) {
	    throw new Error('target dir have to be specified');        
    }
    
    // clear target Folder
    utils.rmSync(targetRoot);

    for (path in this.data) {
        // make relative path
        if (path.substr(0,1) === '/') {
            targetPath = path.replace(root, '');
        } else {
            targetPath = path;
        }
        
        // make abs path to target file
        targetPath = n.path.join(targetRoot, targetPath);
        
        utils.mkdirSync(n.path.dirname(targetPath));

        n.fs.writeFileSync(targetPath, this.data[path]);
    }
    
    return this;
};

proto.end = function() {
    n.util.log('Build was successfull.');
    return this;
};

exports.build = function(opts) {
    return new Build(opts);    
};