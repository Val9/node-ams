/*
 * Read json files generated by tracker-server, do preprocessing stuff,
 * recreate or symlink static files if they has changed.
 */

var $ = require('../deps/sharedjs'),
    n = require('../deps/natives'),
    deps = require('./deps'),
    utils = require('./utils');

/**
 * Default options object
 * @type {Object}
 * @export
 */
exports.options = {
    // processors options
    processors: {
        transport: {
            filter: /require\.js$/
        },
        uglifyjs: true,
        // Attention, order is important!
        vendorcss: true,
        cssmin: true,
        dataimg: true
    },
    copy: {
        src: null, // absolute path to the sources dir
        target: null, // absolute path to the public dir
        pattern: null // regex for enabled files
    },
    combine: {
        // relative path to the bootstrap file for deps detection
        detect: 'main.js',
        paths: null, // like require.paths
        main: null, // abs path to the target file
        pattern: /\.js|\.css$/, // is used if deps is not defined
        filter: null // is used if deps is not defined
    }
};


// require processors
var processors = {};
n.fs.readdirSync(__dirname + '/processors').forEach(function(name) {
    name = name.replace(/\.js$/, '');
    processors[name] = require('./processors/' + name);
});

function process(paths, o) {
    var files = {},
        name, proc, filter,
        i, path;

    for (name in o.processors) {
        proc = processors[name];
        filter = o.processors[name].filter;
        for (i = 0; i < paths.length; ++i) {
            path = paths[i];
            // only read files if they mach any processor pattern
            if (proc.options.pattern.test(path) &&
                (!filter || !filter.test(path))) {
                // check if the path should not be filtered
                files[path] = files[path] || n.fs.readFileSync(path, 'utf-8');
                files[path] = proc.run(path, files[path], o);
                n.fs.writeFileSync(path, files[path]);
            }
        }
    }

    return files;
}


/**
 * Create a build.
 * @param {Object} opts options object, will extend defaults.
 * @export
 */
exports.build = function(opts) {
    var o = $.extend(true, {}, exports.options, opts),
        c = o.copy,
        path, paths,
        files, data = '',
        targetPaths;

    // copy all files
    targetPaths = utils.copySync(c.src, c.target, c.pattern).target;

    // detect dependencies if needed for combiner
    // before running processors, because f.e. js minifier
    // will rename 'require'
    if (o.combine) {
        if (!o.combine.main) {
            throw new Error(
                '"main" have to be defined in "combine" options'
            );
        }
        // find dependencies
        if (o.combine.detect) {
            paths = deps.find(o.combine.main, o.combine.paths);
        // filter paths if needed
        } else {
            paths = [];
            targetPaths.forEach(function(path) {
                // path is pattern valid and is not in filter
                if ((!o.combine.pattern || o.combine.pattern.test(path)) &&
                    (!o.combine.filter || !o.combine.filter.test(path))) {
                    paths.push(path);
                }
            });
        }
    }

    // process files
    if (o.processors) {
        files = process(targetPaths, o);
    }

    // combine files and write them to main
    if (o.combine) {
        paths.forEach(function(path) {
            // file was already loaded by processors
            if (files && files[path]) {
                data += files[path] + '\n';
            } else {
                data += n.fs.readFileSync(path, 'utf-8') + '\n';
            }
        });

        n.fs.writeFileSync(o.combine.main, data);
    }

    n.util.log('Build was successfull.');
};
